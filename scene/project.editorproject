{"MaterialCreatorExtension":[{"name":"Custom material","code":"class Material {\r\n    // Public members\r\n    public time: number = 0;\r\n\r\n    /**\r\n     * Constructor\r\n     */\r\n    constructor () {\r\n\r\n    }\r\n\r\n    /**\r\n     * On initializing the material\r\n     */\r\n    public init (): void {\r\n\r\n    }\r\n\r\n    /**\r\n     * On set the uniforms and samplers of the shader\r\n     * @param uniforms: the uniforms names in the shader\r\n     * @param samplers: the samplers names in the shader\r\n     */\r\n    public setUniforms (uniforms: string[], samplers: string[]): void {\r\n        // Push custom uniforms\r\n        uniforms.push('time');\r\n    }\r\n\r\n    /**\r\n     * Returns if the material is ready for the given submesh\r\n     * @param mesh: the source mesh\r\n     * @param subMesh: the current sub mesh being rendered\r\n     * @param defines: defines related to the current shader\r\n     */\r\n    public isReadyForSubMesh (mesh: BABYLON.Mesh, subMesh: BABYLON.SubMesh, defines: { [index: string]: boolean }): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Bind uniforms for submesh\r\n     * @param world: the world matrix of the mesh\r\n     * @param mesh: the source mesh\r\n     * @param subMesh: the sub mesh being rendered\r\n     * @param effect: the effect which will send the uniforms and samplers to the shader\r\n     */\r\n    public bindForSubMesh (world: BABYLON.Matrix, mesh: BABYLON.Mesh, subMesh: BABYLON.SubMesh, effect: BABYLON.Effect): void {\r\n        const scene = mesh.getScene();\r\n\r\n        // Time\r\n        this.time += scene.getEngine().getDeltaTime() * 0.01;\r\n        effect.setFloat('time', this.time);\r\n    };\r\n\r\n    /**\r\n     * On dispose the material\r\n     */\r\n    public dispose (): void {\r\n\r\n    };\r\n}\r\n\r\nreturn Material;\r\n","vertex":"precision highp float;\r\n\r\n// Attributes\r\nattribute vec3 position;\r\n#ifdef NORMAL\r\nattribute vec3 normal;\r\n#endif\r\n#ifdef UV1\r\nattribute vec2 uv;\r\n#endif\r\n#ifdef UV2\r\nattribute vec2 uv2;\r\n#endif\r\n#ifdef VERTEXCOLOR\r\nattribute vec4 color;\r\n#endif\r\n\r\n#include<bonesDeclaration>\r\n\r\n// Uniforms\r\n#include<instancesDeclaration>\r\n\r\nuniform mat4 view;\r\nuniform mat4 viewProjection;\r\n\r\n#ifdef TEXTURE\r\nvarying vec2 vUV;\r\nuniform mat4 diffuseSamplerMatrix;\r\nuniform vec2 diffuseSamplerInfos;\r\n#endif\r\n\r\n#ifdef POINTSIZE\r\nuniform float pointSize;\r\n#endif\r\n\r\n// Custom\r\nuniform float time;\r\n\r\n// Output\r\nvarying vec3 vPositionW;\r\n#ifdef NORMAL\r\nvarying vec3 vNormalW;\r\n#endif\r\n\r\n#ifdef VERTEXCOLOR\r\nvarying vec4 vColor;\r\n#endif\r\n\r\n#include<clipPlaneVertexDeclaration>\r\n\r\n#include<fogVertexDeclaration>\r\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\r\n\r\nvoid main(void) {\r\n\r\n#include<instancesVertex>\r\n#include<bonesVertex>\r\n\r\n\tvec3 p = position;\r\n\tp.y += sin(time);\r\n\r\n\tgl_Position = viewProjection * finalWorld * vec4(p, 1.0);\r\n\r\n\tvec4 worldPos = finalWorld * vec4(position, 1.0);\r\n\tvPositionW = vec3(worldPos);\r\n\r\n#ifdef NORMAL\r\n\tvNormalW = normalize(vec3(finalWorld * vec4(normal, 0.0)));\r\n#endif\r\n\r\n\t// Texture coordinates\r\n#ifndef UV1\r\n\tvec2 uv = vec2(0., 0.);\r\n#endif\r\n#ifndef UV2\r\n\tvec2 uv2 = vec2(0., 0.);\r\n#endif\r\n\r\n#ifdef TEXTURE\r\n\tif (diffuseSamplerInfos.x == 0.)\r\n\t{\r\n\t\tvUV = vec2(diffuseSamplerMatrix * vec4(uv, 1.0, 0.0));\r\n\t}\r\n\telse\r\n\t{\r\n\t\tvUV = vec2(diffuseSamplerMatrix * vec4(uv2, 1.0, 0.0));\r\n\t}\r\n#endif\r\n\r\n\t// Clip plane\r\n#include<clipPlaneVertex>\r\n\r\n    // Fog\r\n#include<fogVertex>\r\n#include<shadowsVertex>[0..maxSimultaneousLights]\r\n\r\n\t// Vertex color\r\n#ifdef VERTEXCOLOR\r\n\tvColor = color;\r\n#endif\r\n\r\n\t// Point size\r\n#ifdef POINTSIZE\r\n\tgl_PointSize = pointSize;\r\n#endif\r\n}\r\n","pixel":"precision highp float;\r\n\r\n// Constants\r\nuniform vec3 vEyePosition;\r\nuniform vec4 vBaseColor;\r\n\r\n// Input\r\nvarying vec3 vPositionW;\r\n\r\n#ifdef NORMAL\r\nvarying vec3 vNormalW;\r\n#endif\r\n\r\n#ifdef VERTEXCOLOR\r\nvarying vec4 vColor;\r\n#endif\r\n\r\n// Helper functions\r\n#include<helperFunctions>\r\n\r\n// Lights\r\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\r\n\r\n#include<lightsFragmentFunctions>\r\n#include<shadowsFragmentFunctions>\r\n\r\n// Samplers\r\n#ifdef TEXTURE\r\nvarying vec2 vUV;\r\nuniform sampler2D diffuseSampler;\r\nuniform vec2 diffuseSamplerInfos;\r\n\r\nuniform sampler2D otherSampler;\r\n#endif\r\n\r\n#include<clipPlaneFragmentDeclaration>\r\n\r\n// Fog\r\n#include<fogFragmentDeclaration>\r\n\r\nvoid main(void) {\r\n#include<clipPlaneFragment>\r\n\r\n\tvec3 viewDirectionW = normalize(vEyePosition - vPositionW);\r\n\r\n\t// Base color\r\n\tvec4 baseColor = vec4(1., 1., 1., 1.);\r\n\tvec3 diffuseColor = vBaseColor.rgb;\r\n\r\n\t// Alpha\r\n\tfloat alpha = vBaseColor.a;\r\n\r\n#ifdef TEXTURE\r\n\tbaseColor = texture2D(diffuseSampler, vUV);\r\n\tbaseColor *= texture2D(otherSampler, vUV);\r\n\r\n#ifdef ALPHATEST\r\n\tif (baseColor.a < 0.4)\r\n\t\tdiscard;\r\n#endif\r\n\r\n#include<depthPrePass>\r\n\r\n\tbaseColor.rgb *= diffuseSamplerInfos.y;\r\n#endif\r\n\r\n#ifdef VERTEXCOLOR\r\n\tbaseColor.rgb *= vColor.rgb;\r\n#endif\r\n\r\n\t// Normal\r\n#ifdef NORMAL\r\n\tvec3 normalW = normalize(vNormalW);\r\n#else\r\n\tvec3 normalW = vec3(1.0, 1.0, 1.0);\r\n#endif\r\n\r\n\t// Lighting\r\n\tvec3 diffuseBase = vec3(0., 0., 0.);\r\n    lightingInfo info;\r\n\tfloat shadow = 1.;\r\n    float glossiness = 0.;\r\n\r\n#ifdef SPECULARTERM\r\n\tvec3 specularBase = vec3(0., 0., 0.);\r\n#endif    \r\n#include<lightFragment>[0..maxSimultaneousLights]\r\n\r\n#ifdef VERTEXALPHA\r\n\talpha *= vColor.a;\r\n#endif\r\n\r\n\tvec3 finalDiffuse = clamp(diffuseBase * diffuseColor, 0.0, 1.0) * baseColor.rgb;\r\n\r\n\t// Composition\r\n\tvec4 color = vec4(finalDiffuse, alpha);\r\n\r\n#include<fogFragment>\r\n\r\n\tgl_FragColor = color;\r\n}\r\n","config":"{\r\n    \"textures\": [\r\n        { \"name\": \"diffuseSampler\", \"isCube\": false },\r\n        { \"name\": \"otherSampler\", \"isCube\": false }\r\n    ],\r\n    \"floats\": [],\r\n    \"vectors2\": [],\r\n    \"vectors3\": []\r\n}\r\n","userConfig":{"textures":[],"floats":[],"vectors2":[],"vectors3":[]},"compiledCode":"var Material = (function () {\r\n    /**\r\n     * Constructor\r\n     */\r\n    function Material() {\r\n        // Public members\r\n        this.time = 0;\r\n    }\r\n    /**\r\n     * On initializing the material\r\n     */\r\n    Material.prototype.init = function () {\r\n    };\r\n    /**\r\n     * On set the uniforms and samplers of the shader\r\n     * @param uniforms: the uniforms names in the shader\r\n     * @param samplers: the samplers names in the shader\r\n     */\r\n    Material.prototype.setUniforms = function (uniforms, samplers) {\r\n        // Push custom uniforms\r\n        uniforms.push('time');\r\n    };\r\n    /**\r\n     * Returns if the material is ready for the given submesh\r\n     * @param mesh: the source mesh\r\n     * @param subMesh: the current sub mesh being rendered\r\n     * @param defines: defines related to the current shader\r\n     */\r\n    Material.prototype.isReadyForSubMesh = function (mesh, subMesh, defines) {\r\n        return true;\r\n    };\r\n    /**\r\n     * Bind uniforms for submesh\r\n     * @param world: the world matrix of the mesh\r\n     * @param mesh: the source mesh\r\n     * @param subMesh: the sub mesh being rendered\r\n     * @param effect: the effect which will send the uniforms and samplers to the shader\r\n     */\r\n    Material.prototype.bindForSubMesh = function (world, mesh, subMesh, effect) {\r\n        var scene = mesh.getScene();\r\n        // Time\r\n        this.time += scene.getEngine().getDeltaTime() * 0.01;\r\n        effect.setFloat('time', this.time);\r\n    };\r\n    ;\r\n    /**\r\n     * On dispose the material\r\n     */\r\n    Material.prototype.dispose = function () {\r\n    };\r\n    ;\r\n    return Material;\r\n}());\r\nreturn Material;\r\n"}],"BehaviorExtension":{"scripts":[],"nodes":[{"node":"Sphere PBR","nodeId":"Sphere PBR","metadatas":[]},{"node":"Editor Camera","nodeId":"Editor Camera","metadatas":[]},{"node":"Scene","nodeId":"Scene","metadatas":[]}]}}